name: 构建并推送 Vue、Spring Boot 或 Vite 镜像到 GHCR

on:
  push:
    branches:
      - main
    paths:
      - 'vue-frontend/**'
      - 'vite-frontend/**'
      - 'springboot-backend/**'
      - 'go-gost/**'
      - '.github/workflows/docker-build.yml'

  workflow_dispatch:
    inputs:
      commit_sha:
        description: '要构建的 Commit SHA (可选, 默认为 main 分支的 HEAD)'
        required: false
        type: string
      version_tag:
        description: '版本标签 (可选, 如 v1.0.0)。如果为空且未标记为 "latest"，则不会使用其他版本标签。'
        required: false
        type: string
      add_latest_tag:
        description: "是否将此镜像标记为 'latest'?"
        required: true
        type: boolean
        default: true # 确保默认值是 true
      target_app:
        description: '要构建的特定应用程序 (例如 vite-frontend, springboot-backend, all)'
        required: true
        type: string
        default: 'all'
        options:
          - 'all'
          - 'vite-frontend'
          - 'springboot-backend'
          - 'vue-frontend'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  packages: write
  actions: write

jobs:
  setup-docker-build-env:
    name: 设置 Docker 构建环境
    runs-on: ubuntu-latest
    outputs:
      commit_sha: ${{ steps.common_vars.outputs.commit_sha }}
      version_tag: ${{ steps.common_vars.outputs.version_tag }}
      add_latest_tag: ${{ steps.common_vars.outputs.add_latest_tag }}
      target_app: ${{ steps.common_vars.outputs.target_app }}
      event_name: ${{ github.event_name }}
    steps:
      - name: 确定通用构建参数
        id: common_vars
        run: |
          COMMIT_SHA="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.commit_sha || github.sha }}"
          echo "commit_sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"

          VERSION_TAG_OUT=""
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version_tag }}" ]]; then
            VERSION_TAG_OUT="${{ github.event.inputs.version_tag }}"
          # push 事件时，如果 add_latest_tag 也是 true，通常只需要 latest 标签。所以这里留空不会阻止 latest 标签。
          fi
          echo "version_tag=$VERSION_TAG_OUT" >> "$GITHUB_OUTPUT"

          # 确保 add_latest_tag 总是有一个明确的字符串值 'true' 或 'false'
          ADD_LATEST_TAG_OUT=""
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # 对于 workflow_dispatch，直接使用输入值
            ADD_LATEST_TAG_OUT="${{ github.event.inputs.add_latest_tag }}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            # 对于 push，默认总是标记为 latest
            ADD_LATEST_TAG_OUT="true"
          fi
          echo "add_latest_tag=$ADD_LATEST_TAG_OUT" >> "$GITHUB_OUTPUT"
          
          TARGET_APP_OUT="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.target_app || '' }}"
          echo "target_app=$TARGET_APP_OUT" >> "$GITHUB_OUTPUT"

          echo "DEBUG: event_name=${{ github.event_name }}"
          echo "DEBUG: final commit_sha=$COMMIT_SHA"
          echo "DEBUG: final version_tag=$VERSION_TAG_OUT"
          echo "DEBUG: final add_latest_tag=$ADD_LATEST_TAG_OUT"
          echo "DEBUG: final target_app=$TARGET_APP_OUT"


  build-gost:
    if: github.event_name == 'push' && contains(github.event.head_commit.message, '[skip gost]') == false
    name: 构建并压缩 GOST 二进制文件
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v3

      - name: 检查 GOST 更改
        uses: dorny/paths-filter@v2
        id: gost-changes
        with:
          filters: |
            gost:
              - 'go-gost/**'

      - name: 设置 Go 环境
        if: steps.gost-changes.outputs.gost == 'true'
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: 缓存 Go 模块
        if: steps.gost-changes.outputs.gost == 'true'
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: 安装 UPX
        if: steps.gost-changes.outputs.gost == 'true'
        run: |
          wget https://github.com/upx/upx/releases/download/v4.2.1/upx-4.2.1-amd64_linux.tar.xz
          tar -xf upx-4.2.1-amd64_linux.tar.xz
          sudo mv upx-4.2.1-amd64_linux/upx /usr/local/bin/
          rm -rf upx-4.2.1-amd64_linux*

      - name: 构建 GOST 二进制文件
        if: steps.gost-changes.outputs.gost == 'true'
        working-directory: ./go-gost
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o gost

      - name: 使用 UPX 压缩
        if: steps.gost-changes.outputs.gost == 'true'
        working-directory: ./go-gost
        run: |
          upx --best --lzma gost

      - name: 创建或更新 Release
        if: steps.gost-changes.outputs.gost == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          git tag -f gost-latest ${{ github.sha }}
          git push origin gost-latest --force

          if gh release view gost-latest 2>/dev/null; then
            echo "Release exists, will update assets"
          else
            echo "Release not found, creating new release"
            gh release create gost-latest gost-latest \
              --title "GOST Binary Latest" \
              --notes "GOST binary compiled from commit ${{ github.sha }}
          
          - Platform: Linux AMD64
          - Compressed with UPX
          - Build date: ${{ github.event.head_commit.timestamp }}" \
              --repo ${{ github.repository }}
          fi

          gh release upload gost-latest ./go-gost/gost --clobber


  # --- Docker Build Jobs ---

  build-vite:
    needs: setup-docker-build-env
    # 确保这里的 if 条件在评估时，setup-docker-build-env 已经完成
    if: |
      always() && (
        (needs.setup-docker-build-env.outputs.event_name == 'workflow_dispatch' && (needs.setup-docker-build-env.outputs.target_app == 'all' || needs.setup-docker-build-env.outputs.target_app == 'vite-frontend')) ||
        (needs.setup-docker-build-env.outputs.event_name == 'push')
      )
    name: 构建 Vite 前端 - ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            os: ubuntu-latest
          - platform: linux/arm64
            os: ubuntu-latest

    steps:
      - name: 准备平台名称 (环境变量)
        run: |
          echo "PLATFORM_NAME=${{ matrix.platform }}" | sed 's|/|-|g' >> $GITHUB_ENV

      - name: 检查 Vite 更改 (push 事件)
        if: needs.setup-docker-build-env.outputs.event_name == 'push'
        uses: dorny/paths-filter@v2
        id: vite-changes
        with:
          filters: |
            vite:
              - 'vite-frontend/**'
              - '.github/workflows/docker-build.yml'

      - name: 设置构建决策标志
        id: build-decision
        run: |
          SHOULD_RUN_BUILD="false"
          if [[ "${{ needs.setup-docker-build-env.outputs.event_name }}" == "workflow_dispatch" ]]; then
            SHOULD_RUN_BUILD="true"
          elif [[ "${{ needs.setup-docker-build-env.outputs.event_name }}" == "push" ]]; then
            # 这里的 if 条件需要检查 commit message
            if [[ "${{ steps.vite-changes.outputs.vite }}" == "true" && ! contains(github.event.head_commit.message, '[skip vite]') ]]; then
              SHOULD_RUN_BUILD="true"
            fi
          fi
          echo "should_run_build=$SHOULD_RUN_BUILD" >> "$GITHUB_OUTPUT"
          echo "DEBUG: build-vite job (platform ${{ matrix.platform }}): should_run_build=${{ steps.build-decision.outputs.should_run_build }}"

      - name: 检出源代码
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup-docker-build-env.outputs.commit_sha }}

      - name: 设置 Docker Buildx
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: 登录到 GitHub 容器注册表
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置小写仓库所有者名称
        id: lowercase
        if: steps.build-decision.outputs.should_run_build == 'true'
        run: echo "owner=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"
      
      - name: 提取元数据 (标签, 标签)
        id: meta
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.lowercase.outputs.owner }}/vite-frontend
          tags: |
            type=raw,value=${{ needs.setup-docker-build-env.outputs.version_tag }},enable=${{ needs.setup-docker-build-env.outputs.version_tag != '' }}
            type=raw,value=latest,enable=${{ needs.setup-docker-build-env.outputs.add_latest_tag == 'true' }} # 这里的比较是关键
          
      - name: 检查生成的标签 (用于 Build 阶段)
        if: steps.build-decision.outputs.should_run_build == 'true' && steps.meta.outputs.tags == ''
        run: |
          echo "::error::在 Build 阶段，没有为平台 ${{ matrix.platform }} 生成任何标签。请确保提供了版本标签或将 '标记为最新' 设置为 true。"
          exit 1
          
      - name: 构建并推送镜像
        id: build
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./vite-frontend
          file: ./vite-frontend/Dockerfile
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          tags: ${{ steps.meta.outputs.tags }}
          outputs: type=image,name=ghcr.io/${{ steps.lowercase.outputs.owner }}/vite-frontend,name-canonical=true,push=true
          no-cache: true
          pull: true

      - name: 导出摘要
        if: steps.build-decision.outputs.should_run_build == 'true'
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          if [ -z "$digest" ]; then
            echo "::error::构建未产生摘要。这不应该发生。"
            exit 1
          fi
          touch "/tmp/digests/${digest#sha256:}"

      - name: 上传摘要
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: vite-frontend-digests-${{ env.PLATFORM_NAME }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge-vite:
    needs: build-vite
    # 确保这里的 if 条件评估和 build-vite 保持一致
    if: |
      always() && (
        (needs.setup-docker-build-env.outputs.event_name == 'workflow_dispatch' && (needs.setup-docker-build-env.outputs.target_app == 'all' || needs.setup-docker-build-env.outputs.target_app == 'vite-frontend')) ||
        (needs.setup-docker-build-env.outputs.event_name == 'push')
      )
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: 下载摘要
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: vite-frontend-digests-*
          merge-multiple: true

      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 登录到 GitHub 容器注册表
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置小写仓库所有者名称
        id: lowercase
        run: echo "owner=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

      - name: 提取用于合并的元数据
        id: meta_merge
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.lowercase.outputs.owner }}/vite-frontend
          tags: |
            type=raw,value=${{ needs.setup-docker-build-env.outputs.version_tag }},enable=${{ needs.setup-docker-build-env.outputs.version_tag != '' }}
            type=raw,value=latest,enable=${{ needs.setup-docker-build-env.outputs.add_latest_tag == 'true' }} # 这里的比较是关键
      
      - name: 创建清单列表并推送
        working-directory: /tmp/digests
        run: |
          TAG_ARGS=$(echo "${{ steps.meta_merge.outputs.tags }}" | xargs -I {} printf -- "-t {} ")
          
          if [ -z "$TAG_ARGS" ]; then
            echo "::error::在 Merge 阶段，没有为清单列表生成任何标签。请确保在手动触发时提供了版本标签或将 '标记为最新' 设置为 true。对于 Push 事件，'latest' 标签应始终生成。"
            exit 1 # 如果没有标签来创建/推送清单，则以错误退出
          fi
          
          # 检查是否有下载的摘要文件，如果没有，说明 build-vite 没有成功生成镜像
          if [ ! -d "/tmp/digests" ] || [ -z "$(ls -A /tmp/digests)" ]; then
            echo "::error::没有找到任何平台镜像的摘要文件。请检查前面的 build-vite 作业是否成功。"
            exit 1
          fi

          docker buildx imagetools create ${TAG_ARGS} \
            $(printf 'ghcr.io/${{ steps.lowercase.outputs.owner }}/vite-frontend@sha256:%s ' *)

  cleanup-refresh:
    runs-on: ubuntu-latest
    needs:
      - merge-vite
      - build-gost
    if: always()
    steps:
      - name: 删除工作流运行
        uses: Mattraks/delete-workflow-runs@main
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 2
