name: 构建并推送 Vue、Spring Boot 或 Vite 镜像到 GHCR

on:
  push:
    branches:
      - main
    paths:
      - 'vue-frontend/**'
      - 'vite-frontend/**'
      - 'springboot-backend/**'
      - 'go-gost/**'
      - '.github/workflows/docker-build.yml'

  workflow_dispatch:
    inputs:
      commit_sha:
        description: '要构建的 Commit SHA (可选, 默认为 main 分支的 HEAD)'
        required: false
        type: string
      version_tag:
        description: '版本标签 (可选, 如 v1.0.0)。如果为空且未标记为 "latest"，则不会使用其他版本标签。'
        required: false
        type: string
      add_latest_tag:
        description: "是否将此镜像标记为 'latest'?"
        required: true
        type: boolean
        default: true
      target_app:
        description: '要构建的特定应用程序 (例如 vite-frontend, springboot-backend, all)'
        required: true
        type: string
        default: 'all'
        options:
          - 'all'
          - 'vite-frontend'
          - 'springboot-backend'
          - 'vue-frontend'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  packages: write
  actions: write

jobs:
  setup-docker-build-env:
    name: 设置 Docker 构建环境
    runs-on: ubuntu-latest
    outputs:
      commit_sha: ${{ steps.common_vars.outputs.commit_sha }}
      docker_tags: ${{ steps.common_vars.outputs.docker_tags }} # ⭐ 主要输出改变
      target_app: ${{ steps.common_vars.outputs.target_app }}
      event_name: ${{ github.event_name }}
    steps:
      - name: 确定通用构建参数
        id: common_vars
        run: |
          COMMIT_SHA="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.commit_sha || github.sha }}"
          echo "commit_sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"

          # --- 核心修复点 START ---
          # 1. 获取原始输入
          VERSION_TAG_IN=""
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION_TAG_IN="${{ github.event.inputs.version_tag }}"
          fi

          ADD_LATEST_TAG_IN="false"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.add_latest_tag }}" == "true" ]]; then
              ADD_LATEST_TAG_IN="true"
            fi
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            ADD_LATEST_TAG_IN="true"
          fi

          # 2. 根据输入计算最终的 Docker 标签列表（逗号分隔）
          DOCKER_TAGS=""
          if [[ -n "$VERSION_TAG_IN" ]]; then
            DOCKER_TAGS="$VERSION_TAG_IN"
          fi
          if [[ "$ADD_LATEST_TAG_IN" == "true" ]]; then
            if [[ -n "$DOCKER_TAGS" ]]; then
              DOCKER_TAGS="$DOCKER_TAGS,latest"
            else
              DOCKER_TAGS="latest"
            fi
          fi

          # 3. 将计算好的标签列表作为单一输出
          echo "docker_tags=$DOCKER_TAGS" >> "$GITHUB_OUTPUT"
          # --- 核心修复点 END ---

          TARGET_APP_OUT="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.target_app || '' }}"
          echo "target_app=$TARGET_APP_OUT" >> "$GITHUB_OUTPUT"

          echo "DEBUG: event_name=${{ github.event_name }}"
          echo "DEBUG: final commit_sha=$COMMIT_SHA"
          echo "DEBUG: final docker_tags=$DOCKER_TAGS"
          echo "DEBUG: final target_app=$TARGET_APP_OUT"


  build-gost:
    # ... (此作业无需改动，保持原样)
    if: github.event_name == 'push' && contains(github.event.head_commit.message, '[skip gost]') == false
    name: 构建并压缩 GOST 二进制文件
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v3
      - name: 检查 GOST 更改
        uses: dorny/paths-filter@v2
        id: gost-changes
        with:
          filters: |
            gost:
              - 'go-gost/**'
      - name: 设置 Go 环境
        if: steps.gost-changes.outputs.gost == 'true'
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      - name: 缓存 Go 模块
        if: steps.gost-changes.outputs.gost == 'true'
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      - name: 安装 UPX
        if: steps.gost-changes.outputs.gost == 'true'
        run: |
          wget https://github.com/upx/upx/releases/download/v4.2.1/upx-4.2.1-amd64_linux.tar.xz
          tar -xf upx-4.2.1-amd64_linux.tar.xz
          sudo mv upx-4.2.1-amd64_linux/upx /usr/local/bin/
          rm -rf upx-4.2.1-amd64_linux*
      - name: 构建 GOST 二进制文件
        if: steps.gost-changes.outputs.gost == 'true'
        working-directory: ./go-gost
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o gost
      - name: 使用 UPX 压缩
        if: steps.gost-changes.outputs.gost == 'true'
        working-directory: ./go-gost
        run: |
          upx --best --lzma gost
      - name: 创建或更新 Release
        if: steps.gost-changes.outputs.gost == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          git tag -f gost-latest ${{ github.sha }}
          git push origin gost-latest --force
          if gh release view gost-latest 2>/dev/null; then
            echo "Release exists, will update assets"
          else
            echo "Release not found, creating new release"
            gh release create gost-latest gost-latest \
              --title "GOST Binary Latest" \
              --notes "GOST binary compiled from commit ${{ github.sha }}
          - Platform: Linux AMD64
          - Compressed with UPX
          - Build date: ${{ github.event.head_commit.timestamp }}" \
              --repo ${{ github.repository }}
          fi
          gh release upload gost-latest ./go-gost/gost --clobber


  # --- Docker Build Jobs ---

  build-vite:
    needs: setup-docker-build-env
    if: |
      needs.setup-docker-build-env.outputs.docker_tags != '' && (
        (needs.setup-docker-build-env.outputs.event_name == 'workflow_dispatch' && (needs.setup-docker-build-env.outputs.target_app == 'all' || needs.setup-docker-build-env.outputs.target_app == 'vite-frontend')) ||
        (needs.setup-docker-build-env.outputs.event_name == 'push')
      )
    name: 构建 Vite 前端 - ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            os: ubuntu-latest
          - platform: linux/arm64
            os: ubuntu-latest

    steps:
      - name: 准备平台名称 (环境变量)
        run: |
          echo "PLATFORM_NAME=${{ matrix.platform }}" | sed 's|/|-|g' >> $GITHUB_ENV

      - name: 检查 Vite 更改 (push 事件)
        if: needs.setup-docker-build-env.outputs.event_name == 'push'
        uses: dorny/paths-filter@v2
        id: vite-changes
        with:
          filters: |
            vite:
              - 'vite-frontend/**'
              - '.github/workflows/docker-build.yml'

      - name: 设置构建决策标志
        id: build-decision
        run: |
          SHOULD_RUN_BUILD="false"
          EVENT_NAME="${{ needs.setup-docker-build-env.outputs.event_name }}"
          VITE_CHANGES="${{ steps.vite-changes.outputs.vite }}"
          COMMIT_MESSAGE="${{ github.event.head_commit.message }}"

          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            SHOULD_RUN_BUILD="true"
          elif [[ "$EVENT_NAME" == "push" ]]; then
            if [[ "$VITE_CHANGES" == "true" ]]; then
              if ! echo "$COMMIT_MESSAGE" | grep -q '\[skip vite\]'; then
                SHOULD_RUN_BUILD="true"
              fi
            fi
          fi
          echo "should_run_build=$SHOULD_RUN_BUILD" >> "$GITHUB_OUTPUT"
          echo "DEBUG: build-vite job (platform ${{ matrix.platform }}): should_run_build=$SHOULD_RUN_BUILD"

      - name: 检出源代码
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup-docker-build-env.outputs.commit_sha }}

      - name: 设置 Docker Buildx
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: 登录到 GitHub 容器注册表
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置小写仓库所有者名称
        id: lowercase
        if: steps.build-decision.outputs.should_run_build == 'true'
        run: echo "owner=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"
      
      - name: 提取元数据 (标签, 标签)
        id: meta
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.lowercase.outputs.owner }}/vite-frontend
          # ⭐ 简化：直接使用预先计算好的标签
          tags: |
            type=raw,value=${{ needs.setup-docker-build-env.outputs.docker_tags }}
          
      - name: 构建并推送镜像
        id: build
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./vite-frontend
          file: ./vite-frontend/Dockerfile
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          tags: ${{ steps.meta.outputs.tags }} # 这里会接收到 "1.0.0,latest"
          outputs: type=image,name=ghcr.io/${{ steps.lowercase.outputs.owner }}/vite-frontend,name-canonical=true,push=true
          no-cache: true
          pull: true

      - name: 导出摘要
        if: steps.build-decision.outputs.should_run_build == 'true'
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          if [ -z "$digest" ]; then
            echo "::error::构建未产生摘要。这不应该发生，请检查 build 步骤是否成功。"
            exit 1
          fi
          echo "$digest" > "/tmp/digests/${digest//[:]/_}"

      - name: 上传摘要
        if: steps.build-decision.outputs.should_run_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: vite-frontend-digests-${{ env.PLATFORM_NAME }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge-vite:
    needs:
      - setup-docker-build-env
      - build-vite
    if: |
      always() && needs.setup-docker-build-env.outputs.docker_tags != '' && (
        (needs.setup-docker-build-env.outputs.event_name == 'workflow_dispatch' && (needs.setup-docker-build-env.outputs.target_app == 'all' || needs.setup-docker-build-env.outputs.target_app == 'vite-frontend')) ||
        (needs.setup-docker-build-env.outputs.event_name == 'push')
      )
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: 下载摘要
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: vite-frontend-digests-*
          merge-multiple: true

      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 登录到 GitHub 容器注册表
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置小写仓库所有者名称
        id: lowercase
        run: echo "owner=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

      - name: 提取用于合并的元数据
        id: meta_merge
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.lowercase.outputs.owner }}/vite-frontend
          # ⭐ 简化：同样直接使用预先计算好的标签
          tags: |
            type=raw,value=${{ needs.setup-docker-build-env.outputs.docker_tags }}
      
      - name: 创建清单列表并推送
        working-directory: /tmp/digests
        run: |
          # ⭐ 改进的检查逻辑
          if [ ! -d "/tmp/digests" ] || [ -z "$(ls -A /tmp/digests)" ]; then
            echo "::warning::没有找到任何平台镜像的摘要文件。可能是因为上游构建作业因无文件更改而跳过，或构建失败。此合并作业将正常跳过。"
            exit 0 # 正常退出，不报错
          fi

          # 这个检查现在应该永远不会失败了，因为 job-level if 已经保证了 docker_tags 不为空
          TAG_ARGS=$(echo "${{ steps.meta_merge.outputs.tags }}" | xargs -I {} printf -- "-t {} ")
          if [ -z "$TAG_ARGS" ]; then
            echo "::error::严重错误：meta_merge 步骤未能生成标签，即使 docker_tags 输入不为空。输入是：'${{ needs.setup-docker-build-env.outputs.docker_tags }}'"
            exit 1
          fi
          
          DIGESTS_LIST=""
          for f in $(ls -A /tmp/digests/*); do
            DIGEST=$(cat "$f")
            DIGESTS_LIST="$DIGESTS_LIST ghcr.io/${{ steps.lowercase.outputs.owner }}/vite-frontend@$DIGEST"
          done

          docker buildx imagetools create ${TAG_ARGS} ${DIGESTS_LIST}

  cleanup-refresh:
    runs-on: ubuntu-latest
    needs:
      - merge-vite
      - build-gost
    if: always()
    steps:
      - name: 删除工作流运行
        uses: Mattraks/delete-workflow-runs@main
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 2
